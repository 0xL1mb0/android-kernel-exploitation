diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index f6ddec245187..55e2748a13e4 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -4768,10 +4768,12 @@ static int binder_thread_release(struct binder_proc *proc,
 	 * waitqueue_active() is safe to use here because we're holding
 	 * the inner lock.
 	 */
+	/*
 	if ((thread->looper & BINDER_LOOPER_STATE_POLL) &&
 	    waitqueue_active(&thread->wait)) {
 		wake_up_poll(&thread->wait, POLLHUP | POLLFREE);
 	}
+	*/
 
 	binder_inner_proc_unlock(thread->proc);
 
@@ -4781,8 +4783,10 @@ static int binder_thread_release(struct binder_proc *proc,
 	 * descriptor being closed); ep_remove_waitqueue() holds an RCU read
 	 * lock, so we can be sure it's done after calling synchronize_rcu().
 	 */
+	/*
 	if (thread->looper & BINDER_LOOPER_STATE_POLL)
 		synchronize_rcu();
+	*/
 
 	if (send_reply)
 		binder_send_failed_reply(send_reply, BR_DEAD_REPLY);
diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index 7b2fd5f251f2..67af61637f55 100644
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@ -132,19 +132,21 @@
 
 static int copyout(void __user *to, const void *from, size_t n)
 {
-	if (access_ok(VERIFY_WRITE, to, n)) {
+	/*if (access_ok(VERIFY_WRITE, to, n)) {
 		kasan_check_read(from, n);
 		n = raw_copy_to_user(to, from, n);
-	}
+	}*/
+	n = raw_copy_to_user(to, from, n);
 	return n;
 }
 
 static int copyin(void *to, const void __user *from, size_t n)
 {
-	if (access_ok(VERIFY_READ, from, n)) {
+	/*if (access_ok(VERIFY_READ, from, n)) {
 		kasan_check_write(to, n);
 		n = raw_copy_from_user(to, from, n);
-	}
+	}*/
+	n = raw_copy_from_user(to, from, n);
 	return n;
 }
 
